
# Cornell, ECE 3400, Fall 2018

## Camera Setup

*By Katarina Martucci, Avisha Kumar, Liam Patterson, and Emma Kaufman*

Lab 4 instructions include a link to the OV7670 digital camera data sheet. This is the [link](http://web.mit.edu/6.111/www/f2016/tools/OV7670_2006.pdf). DO NOT try to look up this data sheet on your own on Google, there are multiple available on the internet but the registers change slightly depending on which version you use. Make sure you are searching through the provided data sheet link instead.

Use the provided skeleton Arduino code in the lab instructions. The most difficult part of writing this code is setting up the registers. The prelab gives hints about which things you’ll need to change. This tutorial provides a more detailed guide as to which registers you should look at to accomplish the given tasks in the prelab. Refer to pages 10-23 of the data sheet along with this guide in order to complete the camera setup. The first section lists key register names that you should look into further in order to complete setup.

*NOTE: Listed below are the register names. In the Arduino code, you need to use the hex address when reading or writing. The numbers that you write to these registers must also be in hex.*

### Key Register Names:
* COM7: This register is used to reset all of the registers (do this first), enable the color bar, choose QCIF, and output in RGB form.
* CLKRC: This register is to use an external clock.
* COM3: This register is used to enable scaling.
* COM15: This register is used to choose the correct RGB format.
* COM17: This register is used to enable the color bar test. You need to set this along with a bit in COM7 (above) in order for the color bar test to work.
* COM9: Write 0x0B to this register. This instruction was given by the course staff, and is to reduce image noise. It is unnecessary but desired.

### Color Bar Test:
Once you have the color bar test enabled, you must be able to disable it in order to see the actual camera output. In order to disable the color bar, you must explicitly set COM17 to 0x00 and reverse the bit you set in COM7. This should allow you to see the camera output on the monitor rather than the color bar.

### Debugging:
The purpose of read_register_value() is to debug and make sure that the registers are actually being set as they should. If your camera does not seem to be working, add print statements within this function to make sure that after you write to an address, you read back the number that you wanted to set.

### Wiring the Camera:

*Timing - Camera Output Clocks:*
To properly wire the camera, it is important to understand the timing of all components. Checking the data sheet linked above, you can see that the camera outputs three clocks, VSYNC, HREF, and PCLK. Their behaviors are broken down below: 

*VSYNC*
* high when the camera has finished transmitting data from one entire frame
* low before the camera begins its next frame
*HREF*
* high at the beginning of each row of data
* low at the end of each row
*PCLK*
* high every time there is new pixel data available. 

It is important to note that the camera outputs the data for one pixel over two cycles of PCLK. These output clocks from the camera will be wired as inputs to the FPGA in order to indicate when you can sample data. 

*Timing - FPGA Clocks:*
The FPGA generates a 50MHz clock. The camera takes a 24MHz clock as its input, and you will need a 25MHz clock for your VGA driver and M9K RAM. Therefore, it is necessary to implement a Phase-Locked Loop (PLL) as described in the lab, which divides the 50 MHz internal clock into the other necessary clocks. In general, PLLs generate a periodic output signal that is related to the phase of its input signal, which can be used for synchronization, demodulation, and frequency synthesis.  

*Mapping Pins:*
To input or output from the FPGA, you need to use GPIO pins. You can assign specific GPIO pins to be inputs or outputs in your DEO_NANO module. You should assign input pins for the camera output clocks, VSYNC, HREF, and PCLK, and for the D[7:0] pins on the camera, each of which output bits of pixel data. You should assign output pins for the VGA adapter and the 24MHz clock generated by your PLL. Later in the lab, you will need GPIO pins to output your shape and color detection results to your arduino.

*Wiring:*
The camera output clocks and D[7:0] should be wired from the camera to the GPIO pins you assigned to them. The GPIO pin that outputs the 24MHz clock should be wired to the input XCLK on the camera. The camera 3.3V and RESET pins should be wired to power and the ground and PWDN pins to ground. The camera also needs to be wired to the arduino by connecting the camera SIOC and SIOD pins to the arduino SCL and SDA pins. When color and shape detection is ready, you will also need to connect those GPIO output pins to digital pins on your arduino. Be sure to have a common ground!

*General Tips:*
Understanding this wiring will really help you complete downsampling portion of the lab. The three input clocks from the camera tell you when you should be sampling data, as you should only process data in your downsampler when you are in a frame, going through a row, and a byte of data is being transmitted. You should only save data from your downsampling after two bytes of data have been transmitted. The D[7:0] pins help you to figure out which pins you should sample from in order to get the correct bits for your downsampled data. 

Beyond the physical wiring, it is important to know how the entire system is connected together. The arduino sets the registers on the camera. The downsampler takes data from the camera and writes it to the M9K RAM. The VGA driver reads from the M9K RAM and displays the pixel data to the screen. The image processor takes coordinate information from the VGA driver, pixel data from the M9K, and clock information from the PLL generated 25MHz clock and the camera generated VSYNC to check each pixel’s color. The number of pixels of a certain color in any given frame, as well as their locations in a frame, will allow you to do image processing. The result of this image processing will be output to your arduino so it can be integrated into your robot as a whole. 
